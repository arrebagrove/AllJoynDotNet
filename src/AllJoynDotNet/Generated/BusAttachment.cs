// Generated from BusAttachment.h

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace AllJoynDotNet
{
		/// <summary>
		/// Type for the joinsession callback used with the asynchronous joinsession request.
		/// </summary>
		/// 
		internal delegate void alljoyn_busattachment_joinsessioncb_ptr(QStatus status, IntPtr sessionId, IntPtr opts, IntPtr context);
		// typedef void (AJ_CALL * alljoyn_busattachment_joinsessioncb_ptr)(QStatus status, alljoyn_sessionid sessionId, const alljoyn_sessionopts opts, void* context);
		// 

		/// <summary>
		/// Type for the setlinktimeout callback used with the asynchronous setlinktimeout request.
		/// </summary>
		/// <remarks>
		/// <para>Called when alljoyn_busattachment_setlinktimeoutasync() completes.
		/// </para>
		/// </remarks>
		/// <param name="status">ER_OK if successful</param>
		/// <param name="timeout">Timeout value (possibly adjusted from original request).</param>
		/// <param name="context">User defined context which will be passed as-is to callback.</param>
		/// 
		internal delegate void alljoyn_busattachment_setlinktimeoutcb_ptr(QStatus status, UInt32 timeout, IntPtr context);
		// typedef void (AJ_CALL * alljoyn_busattachment_setlinktimeoutcb_ptr)(QStatus status, uint32_t timeout, void* context);
		// 

//
    public partial class BusAttachment : AllJoynWrapper
    {
        internal BusAttachment(IntPtr handle) : base(handle) { }
		/// <summary>
		/// Allocate an alljoyn_busattachment.
		/// </summary>
		/// <remarks>
		/// <para>By default this will create an alljoyn_busattachment capable of handling 4 concurrent method and signal handlers.
		/// This is the recommended default value.  If for some reason the application must be able to handle a different
		/// number of concurrent methods use alljoyn_busattachment_create_concurrency.
		/// </para>
		/// </remarks>
		/// <param name="applicationName">Name of the application.</param>
		/// <param name="allowRemoteMessages">QCC_TRUE if this attachment is allowed to receive messages from remote devices.</param>
		/// <returns>the allocated alljoyn_busattachment</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_busattachment_create([MarshalAs(UnmanagedType.LPStr)]string applicationName, Int32 allowRemoteMessages);
		// extern AJ_API alljoyn_busattachment AJ_CALL alljoyn_busattachment_create(const char* applicationName, QCC_BOOL allowRemoteMessages);

		/// <summary>
		/// Allocate an alljoyn_busattachment.
		/// </summary>
		/// <remarks>
		/// <para>This will Allocate an alljoyn_busattachment that is capable of using a different value for concurrency then
		/// the default value of 4.
		/// </para>
		/// </remarks>
		/// <param name="applicationName">Name of the application.</param>
		/// <param name="allowRemoteMessages">True if this attachment is allowed to receive messages from remote devices.</param>
		/// <param name="concurrency">The maximum number of concurrent method and signal handlers locally executing.</param>
		/// <returns>the allocated alljoyn_busattachment</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_busattachment_create_concurrency([MarshalAs(UnmanagedType.LPStr)]string applicationName, Int32 allowRemoteMessages, UInt32 concurrency);
		// extern AJ_API alljoyn_busattachment AJ_CALL alljoyn_busattachment_create_concurrency(const char* applicationName, QCC_BOOL allowRemoteMessages, uint32_t concurrency);

		/// <summary>
		/// Free an allocated alljoyn_busattachment.
		/// </summary>
		/// <param name="bus">alljoyn_busattachment to free.</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_busattachment_destroy(IntPtr bus);
		// extern AJ_API void AJ_CALL alljoyn_busattachment_destroy(alljoyn_busattachment bus);

		/// <summary>
		/// @brief Start the process of spinning up the independent threads used in
		/// the bus attachment, preparing it for action.
		/// </summary>
		/// <remarks>
		/// <para>This function only begins the process of starting the bus. Sending and
		/// receiving messages cannot begin until the bus is Connect()ed.
		/// </para>
		/// <para>There are two ways to determine whether the bus is currently connected:
		/// -# alljoyn_busattachment() returns QCC_TRUE
		/// -# alljoyn_busobject_callback object_registered is called by the bus
		/// </para>
		/// <para>In most cases, it is not required to understand the threading model of
		/// the bus attachment, with one important exception: The bus attachment may
		/// send callbacks to registered listeners using its own internal threads.
		/// This means that any time a listener of any kind is used in a program, the
		/// implication is that a the overall program is multithreaded, irrespective
		/// of whether or not threads are explicitly used.  This, in turn, means that
		/// any time shared state is accessed in listener callback functions, that state
		/// must be protected.
		/// </para>
		/// <para>As soon as Start() is called, clients of a bus attachment with listeners
		/// must be prepared to receive callbacks on those listeners in the context
		/// of a thread that will be different from the thread running the main
		/// program or any other thread in the client.
		/// </para>
		/// <para>Although intimate knowledge of the details of the threading model are not
		/// required to use a bus attachment (beyond the caveat above) we do provide
		/// functions on the bus attachment that help users reason about more complex
		/// threading situations.  This will apply to situations where clients of the
		/// bus attachment are multithreaded and need to interact with the
		/// multithreaded bus attachment.  These functions can be especially useful
		/// during shutdown, when the two separate threading systems need to be
		/// gracefully brought down together.
		/// </para>
		/// <para>The alljoyn_busattachment function alljoyn_busattachment_start(),
		/// alljoyn_busattachment_stop() and alljoyn_busattacment_join() all work together to
		/// manage the autonomous activities that can happen in an alljoyn_busattachment.
		/// These activities are carried out by so-called hardware threads.  POSIX
		/// defines functions used to control hardware threads, which it calls
		/// pthreads.  Many threading packages use similar constructs.
		/// </para>
		/// <para>In a threading package, a start function asks the underlying system to
		/// arrange for the start of thread execution.  Threads are not necessarily
		/// running when the start function returns, but they are being *started*.  Some time later,
		/// a thread of execution appears in a thread run function, at which point the
		/// thread is considered *running*.  At some later time, executing a stop function asks the
		/// underlying system to arrange for a thread to end its execution.  The system
		/// typically sends a message to the thread to ask it to stop doing what it is doing.
		/// The thread is running until it responds to the stop message, at which time the
		/// run function exits and the thread is considered *stopping*.
		/// </para>
		/// <para>Note that neither alljoyn_busattachment_start() nor alljoyn_busattachment_stop()
		/// are synchronous in the sense that one has actually accomplished the desired
		/// effect upon the return from a call.  Of particular interest is the fact that
		/// after a call to alljoyn_busattachment_stop(), threads will still be *running* for
		/// some non-deterministic time.
		/// </para>
		/// <para>In order to wait until all of the threads have actually stopped, a
		/// blocking call is required.  In threading packages this is typically
		/// called join, and our corresponding function is called alljoyn_busattachment_join().
		/// </para>
		/// <para>An alljoyn_busattachment_start() function call should be thought of as mapping
		/// to a threading package start function.  it causes the activity threads in the
		/// alljoyn_busattachment to be spun up and gets the attachment ready to do its main
		/// job.  As soon as alljoyn_busattachment_start() is called, the user should be prepared
		/// for one or more of these threads of execution to pop out of the bus attachment
		/// and into a listener callback.
		/// </para>
		/// <para>The alljoyn_busattachment_stop() function should be thought of as mapping to a
		/// threading package stop function.  It asks the alljoyn_busattachment to begin
		/// shutting down its various threads of execution, but does not wait for any
		/// threads to exit.
		/// </para>
		/// <para>A call to the alljoyn_busattachment_join() function should be thought of as mapping
		/// to a threading package join function call.  It blocks and waits until all of
		/// the threads in the alljoyn_busattachment have in fact exited their Run functions,
		/// gone through the stopping state and have returned their status.  When
		/// the alljoyn_busattachment_join() function returns, one may be assured that no
		/// threads are running in the bus attachment, and therefore there will be no callbacks
		/// in progress and no further callbacks will ever come out of a particular
		/// instance of a bus attachment.
		/// </para>
		/// <para>It is important to understand that since alljoyn_busattachment_start(),
		/// alljoyn_busattachment_stop() and alljoyn_busattachment_join() map to threads
		/// concepts and functions, one should not expect them to clean up any bus
		/// attachment state when they are called.  These functions are only present to
		/// help in orderly termination of complex threading systems.
		/// </para>
		/// </remarks>
		/// <param name="bus">The alljoyn_busattachment to start.</param>
		/// <returns>- #ER_OK if successful.
		/// - #ER_BUS_BUS_ALREADY_STARTED if already started
		/// - Other error status codes indicating a failure</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_start(IntPtr bus);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_start(alljoyn_busattachment bus);

		/// <summary>
		/// @brief Ask the threading subsystem in the bus attachment to begin the
		/// process of ending the execution of its threads.
		/// </summary>
		/// <remarks>
		/// <para>The alljoyn_busattachment_stop() function call on a bus attachment should be
		/// thought of as mapping to a threading package stop function.  It asks the
		/// alljoyn_busattachment to begin shutting down its various threads of execution, but
		/// does not wait for any threads to exit.
		/// </para>
		/// <para>A call to alljoyn_busattachment_stop() is implied as one of the first steps in
		/// the destruction of a bus attachment.
		/// </para>
		/// </remarks>
		/// <param name="bus">alljoyn_busattachment to stop.</param>
		/// <returns>- #ER_OK if successful.
		/// - An error status if unable to stop the message bus</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_stop(IntPtr bus);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_stop(alljoyn_busattachment bus);

		/// <summary>
		/// @brief Wait for all of the threads spawned by the bus attachment to be
		/// completely exited.
		/// </summary>
		/// <remarks>
		/// <para>A call to the alljoyn_busattachment_join() function should be thought of as
		/// mapping to a threading package join function call.  It blocks and waits
		/// until all of the threads in the alljoyn_busattachment have, in fact, exited
		/// their Run functions, gone through the stopping state and have returned their
		/// status.  When the alljoyn_busattachment_join() function returns, one may be
		/// assured that no threads are running in the bus attachment, and therefore
		/// there will be no callbacks in progress and no further callbacks will ever
		/// come out of the instance of a bus attachment on which
		/// alljoyn_busattachment_join() was called.
		/// </para>
		/// <para>A call to alljoyn_busattachment_join() is implied as one of the first steps
		/// in the destruction of a bus attachment.  Thus, when a bus attachment is
		/// destroyed, it is guaranteed that before it completes its destruction process,
		/// there will be no callbacks in process.
		/// </para>
		/// </remarks>
		/// <param name="bus">alljoyn_busattachment to join.</param>
		/// <returns>- #ER_OK if successful.
		/// - #ER_BUS_BUS_ALREADY_STARTED if already started
		/// - Other error status codes indicating a failure</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_join(IntPtr bus);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_join(alljoyn_busattachment bus);

		/// <summary>
		/// Get the concurrent method and signal handler limit.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment on which to get the concurrent method andsignal handler limit.</param>
		/// <returns>The maximum number of concurrent method and signal handlers.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern UInt32 alljoyn_busattachment_getconcurrency(IntPtr bus);
		// extern AJ_API uint32_t AJ_CALL alljoyn_busattachment_getconcurrency(alljoyn_busattachment bus);

		/// <summary>
		/// Get the connect spec used by the alljoyn_busattachment
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment to obtain the connect spec from.</param>
		/// <returns>The string representing the connect spec used by the alljoyn_busattachment</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_busattachment_getconnectspec(IntPtr bus);
		// extern AJ_API const char* AJ_CALL alljoyn_busattachment_getconnectspec(alljoyn_busattachment bus);

		/// <summary>
		/// Allow the currently executing method/signal handler to enable concurrent callbacks
		/// during the scope of the handler's execution.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment to enable concurrent callbacks on</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_busattachment_enableconcurrentcallbacks(IntPtr bus);
		// extern AJ_API void AJ_CALL alljoyn_busattachment_enableconcurrentcallbacks(alljoyn_busattachment bus);

		/// <summary>
		/// Create an interface description with a given name.
		/// </summary>
		/// <remarks>
		/// <para>Interfaces created using the this function will automatically use
		/// AJ_IFC_SCURITY_INHERIT as its security policy. To create an interface that
		/// uses a different security policy @see alljoyn_busattachment_createinterface_secure
		/// </para>
		/// </remarks>
		/// <param name="bus">The alljoyn_busattachment on which to create an interface.</param>
		/// <param name="name">The requested interface name.</param>
		/// <param name="iface-">Interface description
		/// - NULL if cannot be created.</param><!-- out -->
		/// <returns>- #ER_OK if creation was successful.
		/// - #ER_BUS_IFACE_ALREADY_EXISTS if requested interface already exists</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_createinterface(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string name, IntPtr iface);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_createinterface(alljoyn_busattachment bus, const char* name,alljoyn_interfacedescription* iface);

		/// <summary>
		/// Create an interface description with a given name.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment on which to create an interface.</param>
		/// <param name="name">The requested interface name.</param>
		/// <param name="iface-">Interface description
		/// - NULL if cannot be created.</param><!-- out -->
		/// <param name="secPolicy">security policy of this interface it can be AJ_IFC_SECURITY_INHERIT,AJ_IFC_SECURITY_REQUIRED, or AJ_IFC_SECURITY_OFF</param>
		/// <returns>- #ER_OK if creation was successful.
		/// - #ER_BUS_IFACE_ALREADY_EXISTS if requested interface already exists</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_createinterface_secure(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string name, IntPtr iface, alljoyn_interfacedescription_securitypolicy secPolicy);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_createinterface_secure(alljoyn_busattachment bus, const char* name,alljoyn_interfacedescription* iface,alljoyn_interfacedescription_securitypolicy secPolicy);

		/// <summary>
		/// Connect to a remote bus address.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment to be connected.</param>
		/// <param name="connectSpec">A transport connection spec string of the form:</param>
		/// <returns>- #ER_OK if successful.
		/// - An error status otherwise</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_connect(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string connectSpec);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_connect(alljoyn_busattachment bus, const char* connectSpec);

		/// <summary>
		/// Register an object that will receive bus event notifications.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment on which to attach an alljoyn_buslistener.</param>
		/// <param name="listener">Object instance that will receive bus event notifications.</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_busattachment_registerbuslistener(IntPtr bus, IntPtr listener);
		// extern AJ_API void AJ_CALL alljoyn_busattachment_registerbuslistener(alljoyn_busattachment bus, alljoyn_buslistener listener);

		/// <summary>
		/// Unregister an object that was previously registered with
		/// alljoyn_busattachment_registerbuslistener.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment from which to detach an alljoyn_buslistener.</param>
		/// <param name="listener">Object instance to un-register as a listener.</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_busattachment_unregisterbuslistener(IntPtr bus, IntPtr listener);
		// extern AJ_API void AJ_CALL alljoyn_busattachment_unregisterbuslistener(alljoyn_busattachment bus, alljoyn_buslistener listener);

		/// <summary>
		/// Register interest in a well-known name prefix for the purpose of discovery over transports included in TRANSPORT_ANY.
		/// This method is a shortcut/helper that issues an org.alljoyn.Bus.FindAdvertisedName method call to the local router
		/// and interprets the response.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment on which to register interest in the namePrefix.</param>
		/// <param name="namePrefix">Well-known name prefix that application is interested in receivingalljoyn_buslistener_foundadvertisedname notifications about.</param>
		/// <returns>- #ER_OK iff router response was received and discovery was successfully started.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_findadvertisedname(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string namePrefix);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_findadvertisedname(alljoyn_busattachment bus, const char* namePrefix);

		/// <summary>
		/// Register interest in a well-known name prefix for the purpose of discovery over specified transports.
		/// This method is a shortcut/helper that issues an org.alljoyn.Bus.FindAdvertisedNameByTransport method call to the local router
		/// and interprets the response.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment on which to register interest in the namePrefix.</param>
		/// <param name="namePrefix">Well-known name prefix that application is interested in receivingalljoyn_buslistener_foundadvertisedname notifications about.</param>
		/// <param name="transports">Set of transports to use for discovery.</param>
		/// <returns>- #ER_OK iff router response was received and discovery was successfully started.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_findadvertisednamebytransport(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string namePrefix, UInt16 transports);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_findadvertisednamebytransport(alljoyn_busattachment bus, const char* namePrefix, alljoyn_transportmask transports);

		/// <summary>
		/// Cancel interest in a well-known name prefix that was previously registered
		/// with alljoyn_busattachment_findadvertisedname over transports included in TRANSPORT_ANY.
		/// This method is a shortcut/helper
		/// that issues an org.alljoyn.Bus.CancelFindAdvertisedName method call to the
		/// local router and interprets the response.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment from which to remove interest in the namePrefix.</param>
		/// <param name="namePrefix">Well-known name prefix that application is no longer interested in receivingBusListener::FoundAdvertisedName notifications about.</param>
		/// <returns>- #ER_OK iff router response was received and cancel was successfully completed.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_cancelfindadvertisedname(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string namePrefix);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_cancelfindadvertisedname(alljoyn_busattachment bus, const char* namePrefix);

		/// <summary>
		/// Cancel interest in a well-known name prefix that was previously registered
		/// with alljoyn_busattachment_findadvertisedname over specified transports.  This method is a shortcut/helper
		/// that issues an org.alljoyn.Bus.CancelFindAdvertisedNameByTransport method call to the
		/// local router and interprets the response.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment from which to remove interest in the namePrefix.</param>
		/// <param name="namePrefix">Well-known name prefix that application is no longer interested in receivingBusListener::FoundAdvertisedName notifications about.</param>
		/// <param name="transports">Set of transports to cancel discovery on.</param>
		/// <returns>- #ER_OK iff router response was received and cancel was successfully completed.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_cancelfindadvertisednamebytransport(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string namePrefix, UInt16 transports);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_cancelfindadvertisednamebytransport(alljoyn_busattachment bus, const char* namePrefix, alljoyn_transportmask transports);

		/// <summary>
		/// Advertise the existence of a well-known name to other (possibly disconnected) AllJoyn routers.
		/// </summary>
		/// <remarks>
		/// <para>This method is a shortcut/helper that issues an org.alljoyn.Bus.AdvertisedName method call to the local router
		/// and interprets the response.
		/// </para>
		/// </remarks>
		/// <param name="bus">The bus on which to advertise the name.</param>
		/// <param name="name">the well-known name to advertise. (Must be owned by the caller via RequestName).</param>
		/// <param name="transports">Set of transports to use for sending advertisment.</param>
		/// <returns>- #ER_OK iff router response was received and advertise was successful.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_advertisename(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string name, UInt16 transports);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_advertisename(alljoyn_busattachment bus, const char* name, alljoyn_transportmask transports);

		/// <summary>
		/// Stop advertising the existence of a well-known name to other AllJoyn routers.
		/// </summary>
		/// <remarks>
		/// <para>This method is a shortcut/helper that issues an org.alljoyn.Bus.CancelAdvertiseName method call to the local router
		/// and interprets the response.
		/// </para>
		/// </remarks>
		/// <param name="bus">The bus on which we wish to cancel the name advertisement</param>
		/// <param name="name">A well-known name that was previously advertised via AdvertiseName.</param>
		/// <param name="transports">Set of transports whose name advertisment will be cancelled.</param>
		/// <returns>- #ER_OK iff router response was received and advertisements were sucessfully stopped.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_canceladvertisename(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string name, UInt16 transports);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_canceladvertisename(alljoyn_busattachment bus, const char* name, alljoyn_transportmask transports);

		/// <summary>
		/// Retrieve an existing activated alljoyn_interfacedescription.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment from which to retrieve the interface.</param>
		/// <param name="name">Interface name.</param>
		/// <returns>- A pointer to the registered interface
		/// - NULL if interface doesn't exist</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_busattachment_getinterface(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string name);
		// extern AJ_API const alljoyn_interfacedescription AJ_CALL alljoyn_busattachment_getinterface(alljoyn_busattachment bus, const char* name);

		/// <summary>
		/// Join a session.
		/// This method is a shortcut/helper that issues an org.alljoyn.Bus.JoinSession method call to the local router
		/// and interprets the response.
		/// </summary>
		/// <param name="bus">alljoyn_busattachment with which to join a session.</param>
		/// <param name="sessionHost">Bus name of attachment that is hosting the session to be joined.</param>
		/// <param name="sessionPort">alljoyn_sessionport of sessionHost to be joined.</param>
		/// <param name="listener">Optional listener called when session related events occur. May be NULL.</param>
		/// <param name="sessionId">Unique identifier for session.</param><!-- out -->
		/// <param name="opts">Session options.</param><!-- in, out -->
		/// <returns>- #ER_OK iff router response was received and the session was successfully joined.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_joinsession(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string sessionHost, UInt16 sessionPort, IntPtr listener, IntPtr sessionId, [In, Out]IntPtr opts);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_joinsession(alljoyn_busattachment bus, const char* sessionHost,alljoyn_sessionport sessionPort, alljoyn_sessionlistener listener,alljoyn_sessionid* sessionId, alljoyn_sessionopts opts);

		/// <summary>
		/// Join a session.
		/// This method is a shortcut/helper that issues an org.alljoyn.Bus.JoinSession method call to the local router
		/// and interprets the response.
		/// </summary>
		/// <remarks>
		/// <para>This call executes asynchronously. When the JoinSession response is received, the callback will be called.
		/// </para>
		/// </remarks>
		/// <param name="bus">alljoyn_busattachment with which to join a session.</param>
		/// <param name="sessionHost">Bus name of attachment that is hosting the session to be joined.</param>
		/// <param name="sessionPort">alljoyn_sessionport of sessionHost to be joined.</param>
		/// <param name="listener">Optional listener called when session related events occur. May be NULL.</param>
		/// <param name="opts">Session options.</param>
		/// <param name="callback">Called when JoinSession response is received.</param>
		/// <param name="context">User defined context which will be passed as-is to callback.</param>
		/// <returns>- #ER_OK iff method call to local router response was was successful.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_joinsessionasync(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string sessionHost, UInt16 sessionPort, IntPtr listener, IntPtr opts, alljoyn_busattachment_joinsessioncb_ptr callback, IntPtr context);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_joinsessionasync(alljoyn_busattachment bus,const char* sessionHost,alljoyn_sessionport sessionPort,alljoyn_sessionlistener listener,const alljoyn_sessionopts opts,alljoyn_busattachment_joinsessioncb_ptr callback,void* context);

		/// <summary>
		/// Register a BusObject
		/// </summary>
		/// <param name="bus">The bus on which to register the object.</param>
		/// <param name="obj">BusObject to register.</param>
		/// <returns>- #ER_OK if successful.
		/// - #ER_BUS_BAD_OBJ_PATH for a bad object path
		/// - #ER_BUS_OBJ_ALREADY_EXISTS if an object is already registered at this path</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_registerbusobject(IntPtr bus, IntPtr obj);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_registerbusobject(alljoyn_busattachment bus, alljoyn_busobject obj);

		/// <summary>
		/// Register a BusObject. Bus objects registered using this function will require
		/// authentication. Unless the interfaces security policy is AJ_IFC_SECURITY_OFF.
		/// </summary>
		/// <param name="bus">The bus on which to register the object.</param>
		/// <param name="obj">BusObject to register.</param>
		/// <returns>- #ER_OK if successful.
		/// - #ER_BUS_BAD_OBJ_PATH for a bad object path
		/// - #ER_BUS_OBJ_ALREADY_EXISTS if an object is already registered at this path</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_registerbusobject_secure(IntPtr bus, IntPtr obj);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_registerbusobject_secure(alljoyn_busattachment bus, alljoyn_busobject obj);

		/// <summary>
		/// Unregister a BusObject
		/// </summary>
		/// <param name="bus">The bus from which to unregister the object.</param>
		/// <param name="@object">Object to be unregistered.</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_busattachment_unregisterbusobject(IntPtr bus, IntPtr @object);
		// extern AJ_API void AJ_CALL alljoyn_busattachment_unregisterbusobject(alljoyn_busattachment bus, alljoyn_busobject object);

		/// <summary>
		/// Request a well-known name.
		/// This method is a shortcut/helper that issues an org.freedesktop.DBus.RequestName method call to the local router
		/// and interprets the response.
		/// </summary>
		/// <param name="bus">The bus on which to request the specified name.</param>
		/// <param name="requestedName">Well-known name being requested.</param>
		/// <param name="flags">Bitmask of DBUS_NAME_FLAG_* defines (see DBusStdDefines.h)</param>
		/// <returns>- #ER_OK iff router response was received and request was successful.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_requestname(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string requestedName, UInt32 flags);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_requestname(alljoyn_busattachment bus, const char* requestedName, uint32_t flags);

		/// <summary>
		/// Release a previously requeted well-known name.
		/// This method is a shortcut/helper that issues an org.freedesktop.DBus.ReleaseName method call to the local router
		/// and interprets the response.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment from which to release the name.</param>
		/// <param name="name">Well-known name being released.</param>
		/// <returns>- #ER_OK iff router response was received amd the name was successfully released.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_releasename(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string name);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_releasename(alljoyn_busattachment bus, const char* name);

		/// <summary>
		/// Make an alljoyn_sessionport available for external alljoyn_busattachments to join.
		/// </summary>
		/// <remarks>
		/// <para>Each alljoyn_busattachment binds its own set of alljoyn_sessionports. Session joiners use the
		/// bound session port along with the name of the attachment to create a persistent logical
		/// connection (called a Session) with the original alljoyn_busattachment.
		/// </para>
		/// <para>An alljoyn_sessionport and bus name form a unique identifier that
		/// alljoyn_busattachments use when joining a session.
		/// </para>
		/// <para>alljoyn_sessionport values can be pre-arranged between AllJoyn services and their clients (well-known
		/// alljoyn_sessionports).
		/// </para>
		/// <para>Once a session is joined using one of the service's well-known alljoyn_sessionports,
		/// the service may bind additional alljoyn_sessionports (dynamically) and share
		/// these alljoyn_sessionports with the joiner over the original session.
		/// The joiner can then create additional sessions with the service by calling
		/// JoinSession with these dynamic alljoyn_sessionport ids.
		/// </para>
		/// </remarks>
		/// <param name="bus">The bus on which to make the session port available.</param>
		/// <param name="sessionPort">alljoyn_sessionport value to bind or SESSION_PORT_ANY to allow this methodto choose an available port. On successful return, this value
		/// contains the chosen alljoyn_sessionport.</param><!-- in, out -->
		/// <param name="opts">Session options that joiners must agree to in order tosuccessfully join the session.</param>
		/// <param name="listener">Called by the bus when session related events occur.</param>
		/// <returns>- #ER_OK iff router response was received and the bind operation was successful.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_bindsessionport(IntPtr bus, [In, Out]UInt16 sessionPort, IntPtr opts, IntPtr listener);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_bindsessionport(alljoyn_busattachment bus, alljoyn_sessionport* sessionPort,const alljoyn_sessionopts opts, alljoyn_sessionportlistener listener);

		/// <summary>
		/// Cancel an existing port binding.
		/// </summary>
		/// <param name="bus">The bus on which to cancel the port binding.</param>
		/// <param name="sessionPort">Existing session port to be un-bound.</param>
		/// <returns>- #ER_OK iff router response was received and the bind operation was successful.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_unbindsessionport(IntPtr bus, UInt16 sessionPort);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_unbindsessionport(alljoyn_busattachment bus, alljoyn_sessionport sessionPort);

		/// <summary>
		/// Enable peer-to-peer security. This function must be called by applications that
		/// want to use authentication and encryption. The bus must have been started by calling
		/// alljoyn_busattachment_start() before this function is called. If the application
		/// is providing its own key store implementation it must have already called
		/// alljoyn_busattachment_registerkeystorelistener() before calling this function.
		/// </summary>
		/// <remarks>
		/// <para>Once peer security has been enabled it is not possible to change the authMechanism set without
		/// clearing it first (setting authMechanism to NULL). This is true regardless of whether the BusAttachment
		/// has been disconnected or not.
		/// </para>
		/// </remarks>
		/// <param name="bus">The bus on which to enable security.</param>
		/// <param name="authMechanisms">The authentication mechanism(s) to use for peer-to-peer authentication.If this parameter is NULL peer-to-peer authentication is disabled.
		/// This is a space separated list of any of the following values: ALLJOYN_SRP_LOGON,
		/// ALLJOYN_SRP_KEYX, ALLJOYN_ECDHE_NULL, ALLJOYN_ECDHE_PSK, ALLJOYN_ECDHE_ECDSA, GSSAPI.</param>
		/// <param name="listener">Passes password and other authentication related requests to the application.</param>
		/// <param name="keyStoreFileName">Optional parameter to specify the filename of the default key store. Thedefault value is the applicationName parameter of alljoyn_busattachment_create().
		/// Note that this parameter is only meaningful when using the default
		/// key store implementation.</param>
		/// <param name="isShared">Optional parameter that indicates if the key store is shared between multipleapplications. It is generally harmless to set this to true even when the
		/// key store is not shared but it adds some unnecessary calls to the key store
		/// listener to load and store the key store in this case.</param>
		/// <returns>- #ER_OK if peer security was enabled.
		/// - #ER_BUS_BUS_NOT_STARTED alljoyn_busattachment_start has not been called</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_enablepeersecurity(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string authMechanisms, IntPtr listener, [MarshalAs(UnmanagedType.LPStr)]string keyStoreFileName, Int32 isShared);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_enablepeersecurity(alljoyn_busattachment bus, const char* authMechanisms,alljoyn_authlistener listener, const char* keyStoreFileName,QCC_BOOL isShared);

		/// <summary>
		/// Enable peer-to-peer security. This function must be called by applications that
		/// want to use authentication and encryption. The bus must have been started by calling
		/// alljoyn_busattachment_start() before this function is called. If the application
		/// is providing its own key store implementation it must have already called
		/// alljoyn_busattachment_registerkeystorelistener() before calling this function.
		/// </summary>
		/// <remarks>
		/// <para>Once peer security has been enabled it is not possible to change the authMechanism set without
		/// clearing it first (setting authMechanism to NULL). This is true regardless of whether the BusAttachment
		/// has been disconnected or not.
		/// </para>
		/// </remarks>
		/// <param name="bus">The bus on which to enable security.</param>
		/// <param name="authMechanisms">The authentication mechanism(s) to use for peer-to-peer authentication.If this parameter is NULL peer-to-peer authentication is disabled.
		/// This is a space separated list of any of the following values: ALLJOYN_SRP_LOGON,
		/// ALLJOYN_SRP_KEYX, ALLJOYN_ECDHE_NULL, ALLJOYN_ECDHE_PSK, ALLJOYN_ECDHE_ECDSA, GSSAPI.</param>
		/// <param name="authListener">Passes password and other authentication related requests to the application.</param>
		/// <param name="keyStoreFileName">Optional parameter to specify the filename of the default key store. Thedefault value is the applicationName parameter of alljoyn_busattachment_create().
		/// Note that this parameter is only meaningful when using the default
		/// key store implementation.</param>
		/// <param name="isShared">Optional parameter that indicates if the key store is shared between multipleapplications. It is generally harmless to set this to true even when the
		/// key store is not shared but it adds some unnecessary calls to the key store
		/// listener to load and store the key store in this case.</param>
		/// <param name="permissionConfigurationListener">Passes security 2.0 callbacks to the application.</param>
		/// <returns>- #ER_OK if peer security was enabled.
		/// - #ER_BUS_BUS_NOT_STARTED alljoyn_busattachment_start has not been called</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_enablepeersecuritywithpermissionconfigurationlistener(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string authMechanisms, IntPtr authListener, [MarshalAs(UnmanagedType.LPStr)]string keyStoreFileName, Int32 isShared, IntPtr permissionConfigurationListener);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_enablepeersecuritywithpermissionconfigurationlistener(alljoyn_busattachment bus,const char* authMechanisms,alljoyn_authlistener authListener,const char* keyStoreFileName,QCC_BOOL isShared,alljoyn_permissionconfigurationlistener permissionConfigurationListener);

		/// <summary>
		/// Check is peer security has been enabled for this bus attachment.
		/// </summary>
		/// <param name="bus">The bus on which to query if peer security is enabled.</param>
		/// <returns>Returns QCC_TRUE if peer security has been enabled, QCC_FALSE otherwise.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern Int32 alljoyn_busattachment_ispeersecurityenabled(IntPtr bus);
		// extern AJ_API QCC_BOOL AJ_CALL alljoyn_busattachment_ispeersecurityenabled(alljoyn_busattachment bus);

		/// <summary>
		/// Initialize one more interface descriptions from an XML string in DBus introspection format.
		/// The root tag of the XML can be a \<node\> or a standalone \<interface\> tag. To initialize more
		/// than one interface the interfaces need to be nested in a \<node\> tag.
		/// </summary>
		/// <remarks>
		/// <para>Note that when this method fails during parsing, the return code will be set accordingly.
		/// However, any interfaces which were successfully parsed prior to the failure may be registered
		/// with the bus.
		/// </para>
		/// </remarks>
		/// <param name="bus">The bus on which to create interfaces.</param>
		/// <param name="xml">An XML string in DBus introspection format.</param>
		/// <returns>- #ER_OK if parsing is completely successful.
		/// - An error status otherwise.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_createinterfacesfromxml(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string xml);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_createinterfacesfromxml(alljoyn_busattachment bus, const char* xml);

		/// <summary>
		/// Returns the existing activated InterfaceDescriptions.
		/// </summary>
		/// <param name="bus">The bus to obtaining the interfaces from</param>
		/// <param name="ifaces">A pointer to an InterfaceDescription array to receive the interfaces. Can be NULL inwhich case no interfaces are returned and the return value gives the number
		/// of interfaces available.</param>
		/// <param name="numIfaces">The size of the InterfaceDescription array. If this value is smaller than the totalnumber of interfaces only numIfaces will be returned.</param>
		/// <returns>The number of interfaces returned or the total number of interfaces if ifaces is NULL.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern UInt64 alljoyn_busattachment_getinterfaces(IntPtr bus, IntPtr ifaces, UInt64 numIfaces);
		// extern AJ_API size_t AJ_CALL alljoyn_busattachment_getinterfaces(const alljoyn_busattachment bus,const alljoyn_interfacedescription* ifaces, size_t numIfaces);

		/// <summary>
		/// Delete an interface description with a given name.
		/// </summary>
		/// <remarks>
		/// <para>Deleting an interface is only allowed if that interface has never been activated.
		/// </para>
		/// </remarks>
		/// <param name="bus">The bus from which to delete the interface.</param>
		/// <param name="iface">The un-activated interface to be deleted.</param>
		/// <returns>- #ER_OK if deletion was successful
		/// - #ER_BUS_NO_SUCH_INTERFACE if interface was not found</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_deleteinterface(IntPtr bus, IntPtr iface);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_deleteinterface(alljoyn_busattachment bus, alljoyn_interfacedescription iface);

		/// <summary>
		/// Returns QCC_TRUE if the mesage bus has been started.
		/// </summary>
		/// <param name="bus">The bus to query.</param>
		/// <returns>true if the message bus has been started i.e. alljoyn_busattachment_start() has been called.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern Int32 alljoyn_busattachment_isstarted(IntPtr bus);
		// extern AJ_API QCC_BOOL AJ_CALL alljoyn_busattachment_isstarted(alljoyn_busattachment bus);

		/// <summary>
		/// Indicates #alljoyn_busattachment_stop() has been called
		/// </summary>
		/// <param name="bus">The bus to query.</param>
		/// <returns>QCC_TRUE if the mesage bus has been requested to stop.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern Int32 alljoyn_busattachment_isstopping(IntPtr bus);
		// extern AJ_API QCC_BOOL AJ_CALL alljoyn_busattachment_isstopping(alljoyn_busattachment bus);

		/// <summary>
		/// Indicate whether bus is currently connected.
		/// </summary>
		/// <remarks>
		/// <para>Messages can only be sent or received when the bus is connected.
		/// </para>
		/// </remarks>
		/// <param name="bus">The bus to query.</param>
		/// <returns>true if the bus is connected.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern Int32 alljoyn_busattachment_isconnected(IntPtr bus);
		// extern AJ_API QCC_BOOL AJ_CALL alljoyn_busattachment_isconnected(const alljoyn_busattachment bus);

		/// <summary>
		/// Disconnect a remote bus address connection.
		/// </summary>
		/// <param name="bus">The bus to disconnect.</param>
		/// <param name="unused">Deprecated parameter.</param>
		/// <returns>- #ER_OK if successful
		/// - #ER_BUS_BUS_NOT_STARTED if the bus is not started
		/// - #ER_BUS_NOT_CONNECTED if the %alljoyn_busattachment is not connected to the bus
		/// - Other error status codes indicating a failure</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_disconnect(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string unused);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_disconnect(alljoyn_busattachment bus, const char* unused);

		/// <summary>
		/// Get the org.freedesktop.DBus proxy object.
		/// </summary>
		/// <param name="bus">The bus from which to get the object.</param>
		/// <returns>org.freedesktop.DBus proxy object</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_busattachment_getdbusproxyobj(IntPtr bus);
		// extern AJ_API const alljoyn_proxybusobject AJ_CALL alljoyn_busattachment_getdbusproxyobj(alljoyn_busattachment bus);

		/// <summary>
		/// Get the org.alljoyn.Bus proxy object.
		/// </summary>
		/// <param name="bus">The bus from which to get the object.</param>
		/// <returns>org.alljoyn.Bus proxy object</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_busattachment_getalljoynproxyobj(IntPtr bus);
		// extern AJ_API const alljoyn_proxybusobject AJ_CALL alljoyn_busattachment_getalljoynproxyobj(alljoyn_busattachment bus);

		/// <summary>
		/// Get the org.alljoyn.Debug proxy object.
		/// </summary>
		/// <param name="bus">The bus from which to get the object.</param>
		/// <returns>org.alljoyn.Debug proxy object</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_busattachment_getalljoyndebugobj(IntPtr bus);
		// extern AJ_API const alljoyn_proxybusobject AJ_CALL alljoyn_busattachment_getalljoyndebugobj(alljoyn_busattachment bus);

		/// <summary>
		/// Get the unique name of this alljoyn_busattachment.
		/// </summary>
		/// <param name="bus">The bus to query.</param>
		/// <returns>The unique name of this alljoyn_busattachment.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_busattachment_getuniquename(IntPtr bus);
		// extern AJ_API const char* AJ_CALL alljoyn_busattachment_getuniquename(const alljoyn_busattachment bus);

		/// <summary>
		/// Get the guid of the local router as a string
		/// </summary>
		/// <param name="bus">The bus to query.</param>
		/// <returns>GUID of local AllJoyn router as a string.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_busattachment_getglobalguidstring(IntPtr bus);
		// extern AJ_API const char* AJ_CALL alljoyn_busattachment_getglobalguidstring(const alljoyn_busattachment bus);

		/// <summary>
		/// Register a signal handler.
		/// </summary>
		/// <remarks>
		/// <para>Signals are forwarded to the signalHandler if sender, interface, member and path
		/// qualifiers are ALL met.
		/// </para>
		/// </remarks>
		/// <param name="bus">The alljoyn_busattachment to register the signal handler with</param>
		/// <param name="signal_handler">The signal handler method.</param>
		/// <param name="member">The interface/member of the signal.</param>
		/// <param name="srcPath">The object path of the emitter of the signal or NULL for all paths.</param>
		/// <returns>#ER_OK</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_registersignalhandler(IntPtr bus, alljoyn_messagereceiver_signalhandler_ptr signal_handler, alljoyn_interfacedescription_member member, [MarshalAs(UnmanagedType.LPStr)]string srcPath);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_registersignalhandler(alljoyn_busattachment bus,alljoyn_messagereceiver_signalhandler_ptr signal_handler,const alljoyn_interfacedescription_member member,const char* srcPath);

		/// <summary>
		/// Register a signal handler with a filter rule.
		/// </summary>
		/// <remarks>
		/// <para>Signals are forwarded to the signalHandler if sender, interface, member and rule
		/// qualifiers are ALL met.
		/// </para>
		/// </remarks>
		/// <param name="bus">The alljoyn_busattachment to register the signal handler with</param>
		/// <param name="signal_handler">The signal handler method.</param>
		/// <param name="member">The interface/member of the signal.</param>
		/// <param name="matchRule">The filter rule.</param>
		/// <returns>#ER_OK</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_registersignalhandlerwithrule(IntPtr bus, alljoyn_messagereceiver_signalhandler_ptr signal_handler, alljoyn_interfacedescription_member member, [MarshalAs(UnmanagedType.LPStr)]string matchRule);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_registersignalhandlerwithrule(alljoyn_busattachment bus,alljoyn_messagereceiver_signalhandler_ptr signal_handler,const alljoyn_interfacedescription_member member,const char* matchRule);

		/// <summary>
		/// Unregister a signal handler.
		/// </summary>
		/// <remarks>
		/// <para>Remove the signal handler that was registered with the given parameters.
		/// </para>
		/// </remarks>
		/// <param name="bus">The alljoyn_busattachment to unregister the signal handler with</param>
		/// <param name="signal_handler">The signal handler method.</param>
		/// <param name="member">The interface/member of the signal.</param>
		/// <param name="srcPath">The object path of the emitter of the signal or NULL for all paths.</param>
		/// <returns>#ER_OK</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_unregistersignalhandler(IntPtr bus, alljoyn_messagereceiver_signalhandler_ptr signal_handler, alljoyn_interfacedescription_member member, [MarshalAs(UnmanagedType.LPStr)]string srcPath);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_unregistersignalhandler(alljoyn_busattachment bus,alljoyn_messagereceiver_signalhandler_ptr signal_handler,const alljoyn_interfacedescription_member member,const char* srcPath);

		/// <summary>
		/// Unregister a signal handler with a filter rule.
		/// </summary>
		/// <remarks>
		/// <para>Remove the signal handler that was registered with the given parameters.
		/// </para>
		/// </remarks>
		/// <param name="bus">The alljoyn_busattachment to unregister the signal handler with</param>
		/// <param name="signal_handler">The signal handler method.</param>
		/// <param name="member">The interface/member of the signal.</param>
		/// <param name="matchRule">The filter rule.</param>
		/// <returns>#ER_OK</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_unregistersignalhandlerwithrule(IntPtr bus, alljoyn_messagereceiver_signalhandler_ptr signal_handler, alljoyn_interfacedescription_member member, [MarshalAs(UnmanagedType.LPStr)]string matchRule);

		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_unregistersignalhandlerwithrule(alljoyn_busattachment bus,alljoyn_messagereceiver_signalhandler_ptr signal_handler,const alljoyn_interfacedescription_member member,const char* matchRule);
		/// <summary>
		/// Unregister all signal and reply handlers for the specified alljoyn_busattachment.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment to unregister the signal handler with</param>
		/// <returns>ER_OK if successful.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_unregisterallhandlers(IntPtr bus);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_unregisterallhandlers(alljoyn_busattachment bus);

		/// <summary>
		/// Set a key store listener to listen for key store load and store requests.
		/// This overrides the internal key store listener.
		/// </summary>
		/// <param name="bus">The bus on which to register the key store listener.</param>
		/// <param name="listener">The key store listener to set.</param>
		/// <returns>- #ER_OK if the key store listener was set
		/// - #ER_BUS_LISTENER_ALREADY_SET if a listener has been set by this function or because
		/// alljoyn_busattachment_enablepeersecurity has been called.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_registerkeystorelistener(IntPtr bus, IntPtr listener);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_registerkeystorelistener(alljoyn_busattachment bus, alljoyn_keystorelistener listener);

		/// <summary>
		/// Reloads the key store for this bus attachment. This function would normally only be called in
		/// the case where a single key store is shared between multiple bus attachments, possibly by different
		/// applications. It is up to the applications to coordinate how and when the shared key store is
		/// modified.
		/// </summary>
		/// <param name="bus">The bus on which to reload the key store.</param>
		/// <returns>- ER_OK if the key store was succesfully reloaded- An error status indicating that the key store reload failed.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_reloadkeystore(IntPtr bus);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_reloadkeystore(alljoyn_busattachment bus);

		/// <summary>
		/// Clears all stored keys from the key store. All store keys and authentication information is
		/// deleted and cannot be recovered. Any passwords or other credentials will need to be reentered
		/// when establishing secure peer connections.
		/// </summary>
		/// <param name="bus">The bus on which to clear the key store.</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_busattachment_clearkeystore(IntPtr bus);
		// extern AJ_API void AJ_CALL alljoyn_busattachment_clearkeystore(alljoyn_busattachment bus);

		/// <summary>
		/// Clear the keys associated with aa specific remote peer as identified by its peer GUID. The
		/// peer GUID associated with a bus name can be obtained by calling GetPeerGUID().
		/// </summary>
		/// <param name="bus">The bus from which to clear specific keys.</param>
		/// <param name="guid">The guid of a remote authenticated peer.</param>
		/// <returns>- ER_OK if the keys were cleared- ER_UNKNOWN_GUID if there is no peer with the specified GUID
		/// - Other errors</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_clearkeys(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string guid);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_clearkeys(alljoyn_busattachment bus, const char* guid);

		/// <summary>
		/// Set the expiration time on keys associated with a specific remote peer as identified by its
		/// peer GUID. The peer GUID associated with a bus name can be obtained by calling GetPeerGUID().
		/// If the timeout is 0 this is equivalent to calling ClearKeys().
		/// </summary>
		/// <param name="bus">The bus on which to set a key expiration.</param>
		/// <param name="guid">The GUID of a remote authenticated peer.</param>
		/// <param name="timeout">The time in seconds relative to the current time to expire the keys.</param>
		/// <returns>- ER_OK if the expiration time was succesfully set.- ER_UNKNOWN_GUID if there is no authenticated peer with the specified GUID
		/// - Other errors</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_setkeyexpiration(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string guid, UInt32 timeout);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_setkeyexpiration(alljoyn_busattachment bus, const char* guid, uint32_t timeout);

		/// <summary>
		/// Get the expiration time on keys associated with a specific authenticated remote peer as
		/// identified by its peer GUID. The peer GUID associated with a bus name can be obtained by
		/// calling GetPeerGUID().
		/// </summary>
		/// <param name="bus">The bus to query.</param>
		/// <param name="guid">The GUID of a remote authenticated peer.</param>
		/// <param name="timeout">The time in seconds relative to the current time when the keys will expire.</param>
		/// <returns>- ER_OK if the expiration time was succesfully set.- ER_UNKNOWN_GUID if there is no authenticated peer with the specified GUID
		/// - Other errors</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_getkeyexpiration(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string guid, UInt32[] timeout);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_getkeyexpiration(alljoyn_busattachment bus, const char* guid, uint32_t* timeout);

		/// <summary>
		/// Adds a logon entry string for the requested authentication mechanism to the key store. This
		/// allows an authenticating server to generate offline authentication credentials for securely
		/// logging on a remote peer using a user-name and password credentials pair. This only applies
		/// to authentication mechanisms that support a user name + password logon functionality.
		/// </summary>
		/// <param name="bus">The bus on which to add a logon entry.</param>
		/// <param name="authMechanism">The authentication mechanism.</param>
		/// <param name="userName">The user name to use for generating the logon entry.</param>
		/// <param name="password">The password to use for generating the logon entry. If the password isNULL the logon entry is deleted from the key store.</param>
		/// <returns>- #ER_OK if the logon entry was generated.
		/// - #ER_BUS_INVALID_AUTH_MECHANISM if the authentication mechanism does not support
		/// logon functionality.
		/// - #ER_BAD_ARG_2 indicates a null string was used as the user name.
		/// - #ER_BAD_ARG_3 indicates a null string was used as the password.
		/// - Other error status codes indicating a failure</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_addlogonentry(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string authMechanism, [MarshalAs(UnmanagedType.LPStr)]string userName, [MarshalAs(UnmanagedType.LPStr)]string password);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_addlogonentry(alljoyn_busattachment bus, const char* authMechanism,const char* userName, const char* password);

		/// <summary>
		/// Add a DBus match rule.
		/// This method is a shortcut/helper that issues an org.freedesktop.DBus.AddMatch method call to the local router.
		/// </summary>
		/// <param name="bus">The bus on which to add the match rule.</param>
		/// <param name="rule">Match rule to be added (see DBus specification for format of this string).</param>
		/// <returns>- #ER_OK if the AddMatch request was successful.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_addmatch(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string rule);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_addmatch(alljoyn_busattachment bus, const char* rule);

		/// <summary>
		/// Remove a DBus match rule.
		/// This method is a shortcut/helper that issues an org.freedesktop.DBus.RemoveMatch method call to the local router.
		/// </summary>
		/// <param name="bus">The bus from which to remove the match rule.</param>
		/// <param name="rule">Match rule to be removed (see DBus specification for format of this string).</param>
		/// <returns>- #ER_OK if the RemoveMatch request was successful.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_removematch(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string rule);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_removematch(alljoyn_busattachment bus, const char* rule);

		/// <summary>
		/// Set the SessionListener for an existing sessionId.
		/// Calling this method will override the listener set by a previoius call to SetSessionListener or any
		/// listener specified in JoinSession.
		/// </summary>
		/// <param name="bus">The bus on which to assign the SessionListener.</param>
		/// <param name="sessionId">The session id of an existing session.</param>
		/// <param name="listener">The SessionListener to associate with the session. May be NULL to clear previous listener.</param>
		/// <returns>ER_OK if successful.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_setsessionlistener(IntPtr bus, IntPtr sessionId, IntPtr listener);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_setsessionlistener(alljoyn_busattachment bus, alljoyn_sessionid sessionId,alljoyn_sessionlistener listener);

		/// <summary>
		/// Leave an existing session.
		/// This method is a shortcut/helper that issues an org.alljoyn.Bus.LeaveSession method call to the local router
		/// and interprets the response.
		/// </summary>
		/// <param name="bus">The bus on which to leave the session.</param>
		/// <param name="sessionId">Session id.</param>
		/// <returns>- #ER_OK iff router response was received and the leave operation was successfully completed.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_leavesession(IntPtr bus, IntPtr sessionId);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_leavesession(alljoyn_busattachment bus, alljoyn_sessionid sessionId);

		/// <summary>
		/// Explicitly secure the connection to the remote peer. Peer-to-peer
		/// connections can only be secured if alljoyn_busattachment_enablepeersecurity() was previously called on the bus
		/// attachment. If the peer-to-peer connection is already secure this
		/// function does nothing. Note that peer-to-peer connections are automatically secured when a
		/// method call requiring encryption is sent.
		/// </summary>
		/// <remarks>
		/// <para>This call causes messages to be sent on the bus, therefore it cannot be called within AllJoyn
		/// callbacks (method/signal/reply handlers or ObjectRegistered callbacks, etc.)
		/// </para>
		/// </remarks>
		/// <param name="bus">The busattachment on which to secure the connection.</param>
		/// <param name="name">The unique name of the remote peer or NULL to secure the connections to all peersthis alljoyn_busattachment is in session with.</param>
		/// <param name="forceAuth">If true, forces re-authentication even if the peer connection is alreadyauthenticated.</param>
		/// <returns>- #ER_OK if the connection was secured or an error status indicating that the
		/// connection could not be secured.
		/// - #ER_BUS_NO_AUTHENTICATION_MECHANISM if alljoyn_busattachment_enablepeersecurity() has not been called.
		/// - #ER_AUTH_FAIL if the attempt(s) to authenticate the peer failed.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_secureconnection(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string name, Int32 forceAuth);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_secureconnection(alljoyn_busattachment bus, const char* name, QCC_BOOL forceAuth);

		/// <summary>
		/// Asynchronously secure the connection to the remote peer. Peer-to-peer connections can only
		/// be secured if alljoyn_busattachment_enablepeersecurity() was previously called on the bus attachment.
		/// If the peer-to-peer connection is already secure this function does nothing.
		/// Note that peer-to-peer connections are automatically secured when a
		/// method call requiring encryption is sent.
		/// </summary>
		/// <remarks>
		/// <para>Notification of success or failure is via the alljoyn_authlistener passed to alljoyn_busattachment_enablepeersecurity().
		/// </para>
		/// </remarks>
		/// <param name="bus">The busattachment on which to secure the connection.</param>
		/// <param name="name">The unique name of the remote peer or NULL to secure the connections to all peersthis alljoyn_busattachment is in session with.</param>
		/// <param name="forceAuth">If true, forces re-authentication even if the peer connection is alreadyauthenticated.</param>
		/// <returns>- #ER_OK if securing could begin.
		/// - #ER_BUS_NO_AUTHENTICATION_MECHANISM if alljoyn_busattachment_enablepeersecurity() has not been called.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_secureconnectionasync(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string name, Int32 forceAuth);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_secureconnectionasync(alljoyn_busattachment bus, const char* name, QCC_BOOL forceAuth);

		/// <summary>
		/// Remove a member from an existing multipoint session.
		/// This function may be called by the binder of the session to forcefully remove a member from a session.
		/// </summary>
		/// <remarks>
		/// <para>This method is a shortcut/helper that issues an org.alljoyn.Bus.RemoveSessionMember method call to the local router
		/// and interprets the response.
		/// </para>
		/// </remarks>
		/// <param name="bus">The bus which the member is being removed from</param>
		/// <param name="sessionId">Session id.</param>
		/// <param name="memberName">Member to remove.</param>
		/// <returns>- #ER_OK iff router response was received and the remove member operation was successfully completed.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_removesessionmember(IntPtr bus, IntPtr sessionId, [MarshalAs(UnmanagedType.LPStr)]string memberName);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_removesessionmember(alljoyn_busattachment bus, alljoyn_sessionid sessionId, const char* memberName);

		/// <summary>
		/// Set the link timeout for a session.
		/// </summary>
		/// <remarks>
		/// <para>Link timeout is the maximum number of seconds that an unresponsive router-to-router connection
		/// will be monitored before declaring the session lost (via SessionLost callback). Link timeout
		/// defaults to 0 which indicates that AllJoyn link monitoring is disabled.
		/// </para>
		/// <para>Each transport type defines a lower bound on link timeout to avoid defeating transport
		/// specific power management algorithms.
		/// </para>
		/// </remarks>
		/// <param name="bus">The bus containing the link to modify.</param>
		/// <param name="sessionid">Id of session whose link timeout will be modified.</param>
		/// <param name="linkTimeout">[IN/OUT] Max number of seconds that a link can be unresponsive before beingdeclared lost. 0 indicates that AllJoyn link monitoring will be disabled. On
		/// return, this value will be the resulting (possibly upward) adjusted linkTimeout
		/// value that acceptable to the underlying transport.</param>
		/// <returns>- #ER_OK if successful
		/// - #ER_ALLJOYN_SETLINKTIMEOUT_REPLY_NOT_SUPPORTED if local router does not support SetLinkTimeout
		/// - #ER_ALLJOYN_SETLINKTIMEOUT_REPLY_NO_DEST_SUPPORT if SetLinkTimeout not supported by destination
		/// - #ER_BUS_NO_SESSION if the Session id is not valid
		/// - #ER_ALLJOYN_SETLINKTIMEOUT_REPLY_FAILED if SetLinkTimeout failed
		/// - #ER_BUS_NOT_CONNECTED if the alljoyn_busattachment is not connected to the router</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_setlinktimeout(IntPtr bus, IntPtr sessionid, UInt32[] linkTimeout);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_setlinktimeout(alljoyn_busattachment bus, alljoyn_sessionid sessionid, uint32_t* linkTimeout);

		/// <summary>
		/// Set the link timeout for a session.
		/// </summary>
		/// <remarks>
		/// <para>Link timeout is the maximum number of seconds that an unresponsive
		/// router-to-router connection will be monitored before declaring the session
		/// lost (via SessionLost callback). Link timeout defaults to 0 which indicates
		/// that AllJoyn link monitoring is disabled.
		/// </para>
		/// <para>Each transport type defines a lower bound on link timeout to avoid defeating
		/// transport specific power management algorithms.
		/// </para>
		/// <para>This call executes asynchronously. When the alljoyn_busattachment_setlinktimeoutasync
		/// response is received, the callback will be called.
		/// </para>
		/// </remarks>
		/// <param name="bus">The bus containing the link to modify.</param>
		/// <param name="sessionid">Id of session whose link timeout will be modified.</param>
		/// <param name="linkTimeout">Max number of seconds that a link can be unresponsive before beingdeclared lost. 0 indicates that AllJoyn link monitoring will be disabled. On
		/// return, this value will be the resulting (possibly upward) adjusted linkTimeout
		/// value that acceptable to the underlying transport.</param>
		/// <param name="callback">alljoyn_busattachment_setlinktimeoutcb_ptr functionCalled when alljoyn_busattachment_setlinktimeoutasync
		/// response is received.</param>
		/// <param name="context">User defined context which will be passed as-is to callback.</param>
		/// <returns>- #ER_OK iff method call to local router response was was successful.
		/// - #ER_BUS_NOT_CONNECTED if a connection has not been made with a local bus.
		/// - Other error status codes indicating a failure.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_setlinktimeoutasync(IntPtr bus, IntPtr sessionid, UInt32 linkTimeout, alljoyn_busattachment_setlinktimeoutcb_ptr callback, IntPtr context);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_setlinktimeoutasync(alljoyn_busattachment bus, alljoyn_sessionid sessionid,uint32_t linkTimeout, alljoyn_busattachment_setlinktimeoutcb_ptr callback,void* context);

		/// <summary>
		/// Determine whether a given well-known name exists on the bus.
		/// This method is a shortcut/helper that issues an org.freedesktop.DBus.NameHasOwner method call to the router
		/// and interprets the response.
		/// </summary>
		/// <param name="bus">The bus to query.</param>
		/// <param name="name">The well known name that the caller is inquiring about.</param>
		/// <param name="hasOwner">If return is ER_OK, indicates whether name exists on the bus.If return is not ER_OK, param is not modified.</param><!-- out -->
		/// <returns>- #ER_OK if name ownership was able to be determined.
		/// - An error status otherwise</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_namehasowner(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string name, Int32 hasOwner);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_namehasowner(alljoyn_busattachment bus, const char* name, QCC_BOOL* hasOwner);

		/// <summary>
		/// Get the peer GUID for this peer of the local peer or an authenticated remote peer. The bus
		/// names of a remote peer can change over time, specifically the unique name is different each
		/// time the peer connects to the bus and a peer may use different well-known-names at different
		/// times. The peer GUID is the only persistent identity for a peer. Peer GUIDs are used by the
		/// authentication mechanisms to uniquely and identify a remote application instance. The peer
		/// GUID for a remote peer is only available if the remote peer has been authenticated.
		/// </summary>
		/// <param name="bus">The bus on which to get the peer GUID.</param>
		/// <param name="name">Name of a remote peer or NULL to get the local (this application's) peer GUID.</param>
		/// <param name="guid">Returns the guid for the local or remote peer depending on the value of name, or NULL to get size.</param>
		/// <param name="guidSz">Size of the provided guid buffer, upon exit size of guid string.</param>
		/// <returns>- #ER_OK if the requested GUID was obtained.
		/// - An error status otherwise.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_getpeerguid(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string name, [MarshalAs(UnmanagedType.LPStr)]string guid, UInt64[] guidSz);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_getpeerguid(alljoyn_busattachment bus, const char* name, char* guid, size_t* guidSz);

		/// <summary>
		/// This sets the debug level of the local AllJoyn router if that router
		/// was built in debug mode.
		/// </summary>
		/// <remarks>
		/// <para>The debug level can be set for individual subsystems or for "ALL"
		/// subsystems.  Common subsystems are "ALLJOYN" for core AllJoyn code,
		/// "ALLJOYN_OBJ" for the sessions management code and "ALLJOYN_NS"
		/// for the TCP name services.  Debug levels for specific subsystems
		/// override the setting for "ALL" subsystems.  For example if "ALL" is
		/// set to 7, but "ALLJOYN_OBJ" is set to 1, then detailed debug output
		/// will be generated for all subsystems expcept for "ALLJOYN_OBJ"
		/// which will only generate high level debug output.  "ALL" defaults
		/// to 0 which is off, or no debug output.
		/// </para>
		/// <para>The debug output levels are actually a bit field that controls what
		/// output is generated.  Those bit fields are described below:
		/// </para>
		/// <para>- 0x1: High level debug prints (these debug printfs are not common)
		/// - 0x2: Normal debug prints (these debug printfs are common)
		/// - 0x4: Function call tracing (these debug printfs are used
		/// sporadically)
		/// - 0x8: Data dump (really only used in the "SOCKET" module - can
		/// generate a *lot* of output)
		/// </para>
		/// <para>Typically, when enabling debug for a subsystem, the level would be set
		/// to 7 which enables High level debug, normal debug, and function call
		/// tracing.  Setting the level 0, forces debug output to be off for the
		/// specified subsystem.
		/// </para>
		/// </remarks>
		/// <param name="bus">bus on which to set debugging.</param>
		/// <param name="module">name of the module to generate debug output</param>
		/// <param name="level">debug level to set for the module</param>
		/// <returns>- #ER_OK if debug request was successfully sent to the AllJoyn
		/// router.
		/// - #ER_BUS_NO_SUCH_OBJECT if router was not built in debug mode.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_setdaemondebug(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string module, UInt32 level);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_setdaemondebug(alljoyn_busattachment bus, const char* module, uint32_t level);

		/// <summary>
		/// Returns the current non-absolute real-time clock used internally by AllJoyn. This value can be
		/// compared with the timestamps on messages to calculate the time since a timestamped message
		/// was sent.
		/// </summary>
		/// <returns>The current timestamp in milliseconds.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern UInt32 alljoyn_busattachment_gettimestamp();
		// extern AJ_API uint32_t AJ_CALL alljoyn_busattachment_gettimestamp();

		/// <summary>
		/// Determine if you are able to find a remote connection based on its BusName.
		/// The BusName can be the Unique or well-known name.
		/// </summary>
		/// <param name="bus">alljoyn_busattachment</param>
		/// <param name="name">The unique or well-known name to ping</param>
		/// <param name="timeout">Timeout specified in milliseconds to wait for reply</param>
		/// <returns>- #ER_OK the name is present and responding
		/// - #ER_ALLJOYN_PING_REPLY_UNREACHABLE the name is no longer present
		/// <br>
		/// The following return values indicate that the router cannot determine if the
		/// remote name is present and responding:
		/// - #ER_ALLJOYN_PING_REPLY_TIMEOUT Ping call timed out
		/// - #ER_ALLJOYN_PING_REPLY_UNKNOWN_NAME name not found currently or not part of any known session
		/// - #ER_ALLJOYN_PING_REPLY_INCOMPATIBLE_REMOTE_ROUTING_NODE the remote routing node does not implement Ping
		/// <br>
		/// The following return values indicate an error with the ping call itself:
		/// - #ER_ALLJOYN_PING_FAILED Ping failed
		/// - #ER_BUS_UNEXPECTED_DISPOSITION An unexpected disposition was returned and has been treated as an error
		/// - #ER_BUS_NOT_CONNECTED the BusAttachment is not connected to the bus
		/// - #ER_BUS_BAD_BUS_NAME the name parameter is not a valid bus name
		/// - An error status otherwise</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_ping(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string name, UInt32 timeout);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_ping(alljoyn_busattachment bus, const char* name, uint32_t timeout);

		/// <summary>
		/// Registers a handler to receive the org.alljoyn.about Announce signal.
		/// </summary>
		/// <remarks>
		/// <para>The handler is only called if a call to alljoyn_busattachment_whoimplements_*
		/// has been has been called.
		/// </para>
		/// <para>Important: the alljoyn_aboutlistener should be registered before calling
		/// alljoyn_busattachment_whoimplments_*
		/// </para>
		/// </remarks>
		/// <param name="bus">alljoyn_busattachment this call is made for</param>
		/// <param name="aboutListener">alljoyn_aboutlistener to be registered</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_busattachment_registeraboutlistener(IntPtr bus, IntPtr aboutListener);
		// extern AJ_API void AJ_CALL alljoyn_busattachment_registeraboutlistener(alljoyn_busattachment bus,alljoyn_aboutlistener aboutListener);

		/// <summary>
		/// Unregisters the AnnounceHandler from receiving the org.alljoyn.about Announce signal.
		/// </summary>
		/// <param name="bus">alljoyn_busattachment this call is made for</param>
		/// <param name="aboutListener">alljoyn_aboutlistener to be unregistered</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_busattachment_unregisteraboutlistener(IntPtr bus, IntPtr aboutListener);
		// extern AJ_API void AJ_CALL alljoyn_busattachment_unregisteraboutlistener(alljoyn_busattachment bus,alljoyn_aboutlistener aboutListener);

		/// <summary>
		/// Unregisters all AboutListeners from receiving any org.alljoyn.about Announce signal
		/// </summary>
		/// <param name="bus">alljoyn_busattachment this call is made for</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_busattachment_unregisterallaboutlisteners(IntPtr bus);
		// extern AJ_API void AJ_CALL alljoyn_busattachment_unregisterallaboutlisteners(alljoyn_busattachment bus);

		/// <summary>
		/// List the interfaces the application is interested in.  If a remote device
		/// is announcing that interface then all registered listeners for About
		/// will be called.
		/// </summary>
		/// <remarks>
		/// <para>It's the About listener's responsibility to parse through the reported
		/// interfaces to figure out what should be done in response to the Announce
		/// signal.
		/// </para>
		/// <para>This call is ref counted. If this function is called with the same
		/// list of interfaces multiple times then alljoyn_busattachment_cancelwhoimplements_interfaces
		/// must also be called multiple times with the same list of interfaces.
		/// </para>
		/// <para>Note: specifying NULL for the implementsInterfaces parameter could have
		/// significant impact on network performance and should be avoided unless
		/// all announcements are needed.
		/// </para>
		/// </remarks>
		/// <param name="bus">alljoyn_busattachment this call is made for</param>
		/// <param name="implementsInterfaces">a list of interfaces that the Announce signalreports as implemented. NULL to receive all
		/// Announce signals regardless of interfaces</param>
		/// <param name="numberInterfaces">the number of interfaces in theimplementsInterfaces list</param>
		/// <returns>status</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_whoimplements_interfaces(IntPtr bus, [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)]string[] implementsInterfaces, UInt64 numberInterfaces);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_whoimplements_interfaces(alljoyn_busattachment bus,const char** implementsInterfaces,size_t numberInterfaces);

		/// <summary>
		/// List an interface the application is interested in.  If a remote device
		/// is announcing that interface then all registered listeners for the
		/// Announce signal will be called.
		/// </summary>
		/// <remarks>
		/// <para>This is identical to alljoyn_busattachment_whoimplements_interfaces
		/// except this is specialized for a single interface not several interfaces.
		/// </para>
		/// <para>Note: specifying NULL for the interface parameter could have significant
		/// impact on network performance and should be avoided unless all
		/// announcements are needed.
		/// </para>
		/// </remarks>
		/// <param name="bus">alljoyn_busattachment this call is made for</param>
		/// <param name="implementsInterface">interface that must be implemented in orderto receive the announce signal.</param>
		/// <returns>- #ER_OK on success
		/// - An error status otherwise</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_whoimplements_interface(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string implementsInterface);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_whoimplements_interface(alljoyn_busattachment bus,const char* implementsInterface);

		/// <summary>
		/// Stop showing interest in the listed interfaces. Stop receiving announce
		/// signals from the devices with the listed interfaces.
		/// </summary>
		/// <remarks>
		/// <para>Note if alljoyn_busattachment_whoimplements_interfaces has been called multiple
		/// times the announce signal will still be received for any interfaces that still remain.
		/// </para>
		/// </remarks>
		/// <param name="bus">alljoyn_busattachment this call is made for</param>
		/// <param name="implementsInterfaces">a list of interfaces. The list must match thelist previously passed to the WhoImplements
		/// member function</param>
		/// <param name="numberInterfaces">the number of interfaces in theimplementsInterfaces list</param>
		/// <returns>- #ER_OK on success
		/// - #ER_BUS_MATCH_RULE_NOT_FOUND if interfaces added using the WhoImplements
		/// member function were not found.
		/// - An error status otherwise</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_cancelwhoimplements_interfaces(IntPtr bus, [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)]string[] implementsInterfaces, UInt64 numberInterfaces);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_cancelwhoimplements_interfaces(alljoyn_busattachment bus,const char** implementsInterfaces,size_t numberInterfaces);

		/// <summary>
		/// Stop showing interest in the listed interfaces. Stop receiving announce
		/// signals from the devices with the listed interfaces.
		/// </summary>
		/// <remarks>
		/// <para>This is identical to alljoyn_busattachment_cancelwhoimplements_interfaces
		/// except this is specialized for a single interface not several interfaces.
		/// </para>
		/// </remarks>
		/// <param name="bus">alljoyn_busattachment this call is made for</param>
		/// <param name="implementsInterface">interface that must be implement in order toreceive the announce signal.</param>
		/// <returns>- #ER_OK on success
		/// - #ER_BUS_MATCH_RULE_NOT_FOUND if interface added using the WhoImplements
		/// member function were not found.
		/// - An error status otherwise</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_busattachment_cancelwhoimplements_interface(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string implementsInterface);
		// extern AJ_API QStatus AJ_CALL alljoyn_busattachment_cancelwhoimplements_interface(alljoyn_busattachment bus,const char* implementsInterface);


    }
}