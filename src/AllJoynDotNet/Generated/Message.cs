// Generated from Message.h

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace AllJoynDotNet
{
		/// <summary>
		/// The default timeout for method calls
		/// </summary>
		/// 
		internal enum alljoyn_messagetype
		{
		
		ALLJOYN_MESSAGE_INVALID     = 0, ///< an invalid message type
		ALLJOYN_MESSAGE_METHOD_CALL = 1, ///< a method call message type
		ALLJOYN_MESSAGE_METHOD_RET  = 2, ///< a method return message type
		ALLJOYN_MESSAGE_ERROR       = 3, ///< an error message type
		ALLJOYN_MESSAGE_SIGNAL      = 4  ///< a signal message type
		
		}
		// typedef enum {
		// ALLJOYN_MESSAGE_INVALID     = 0, ///< an invalid message type
		// ALLJOYN_MESSAGE_METHOD_CALL = 1, ///< a method call message type
		// ALLJOYN_MESSAGE_METHOD_RET  = 2, ///< a method return message type
		// ALLJOYN_MESSAGE_ERROR       = 3, ///< an error message type
		// ALLJOYN_MESSAGE_SIGNAL      = 4  ///< a signal message type
		// } alljoyn_messagetype;
		// 

//
    public partial class Message : AllJoynWrapper
    {
        internal Message(IntPtr handle) : base(handle) { }
		/// <summary>
		/// Create an alljoyn_message object.
		/// </summary>
		/// <param name="bus">The alljoyn_busattachment that this alljoyn_message is sent or received on.</param>
		/// <returns>the allocated alljoyn_message</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_create(IntPtr bus);
		// extern AJ_API alljoyn_message AJ_CALL alljoyn_message_create(alljoyn_busattachment bus);

		/// <summary>
		/// Destroy an alljoyn_message object.
		/// </summary>
		/// <param name="msg">The alljoyn_message to destroy</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_message_destroy(IntPtr msg);
		// extern AJ_API void AJ_CALL alljoyn_message_destroy(alljoyn_message msg);

		/// <summary>
		/// Determine if message is a broadcast signal.
		/// </summary>
		/// <param name="msg">alljoyn_message we wish to determine if it is a broadcast signal.</param>
		/// <returns>Return true if this is a broadcast signal.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern Int32 alljoyn_message_isbroadcastsignal(IntPtr msg);
		// extern AJ_API QCC_BOOL AJ_CALL alljoyn_message_isbroadcastsignal(alljoyn_message msg);

		/// <summary>
		/// Messages broadcast to all devices are global broadcast messages.
		/// </summary>
		/// <param name="msg">alljoyn_message we wish to determine if it is a global broadcast signal.</param>
		/// <returns>Return true if this is a global broadcast message.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern Int32 alljoyn_message_isglobalbroadcast(IntPtr msg);
		// extern AJ_API QCC_BOOL AJ_CALL alljoyn_message_isglobalbroadcast(alljoyn_message msg);

		/// <summary>
		/// Messages sent without sessions are sessionless.
		/// </summary>
		/// <param name="msg">alljoyn_message we wish to determine if it is a sessionless signal.</param>
		/// <returns>Return true if this is a sessionless message.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern Int32 alljoyn_message_issessionless(IntPtr msg);
		// extern AJ_API QCC_BOOL AJ_CALL alljoyn_message_issessionless(alljoyn_message msg);

		/// <summary>
		/// Returns the flags for the message.
		/// </summary>
		/// <param name="msg">alljoyn_message we wish to get the flags from.</param>
		/// <returns>flags for the message</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern byte alljoyn_message_getflags(IntPtr msg);
		// extern AJ_API uint8_t AJ_CALL alljoyn_message_getflags(alljoyn_message msg);

		/// <summary>
		/// Return true if message's TTL header indicates that it is expired
		/// </summary>
		/// <param name="msg">alljoyn_message we are checking the TTL header for expiration.</param>
		/// <param name="tillExpireMS">Written with number of milliseconds before message expires if non-nullIf message never expires value is set to the maximum uint32_t value.</param><!-- out -->
		/// <returns>Returns true if the message's TTL header indicates that is has expired.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern Int32 alljoyn_message_isexpired(IntPtr msg, UInt32 tillExpireMS);
		// extern AJ_API QCC_BOOL AJ_CALL alljoyn_message_isexpired(alljoyn_message msg, uint32_t* tillExpireMS);

		/// <summary>
		/// Determine if the message is marked as unreliable. Unreliable messages have a non-zero
		/// time-to-live and may be silently discarded.
		/// </summary>
		/// <param name="msg">alljoyn_message being checked to see if it is marked as unrliable</param>
		/// <returns>Returns true if the message is unreliable, that is, has a non-zero time-to-live.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern Int32 alljoyn_message_isunreliable(IntPtr msg);
		// extern AJ_API QCC_BOOL AJ_CALL alljoyn_message_isunreliable(alljoyn_message msg);

		/// <summary>
		/// Determine if the message was encrypted.
		/// </summary>
		/// <param name="msg">alljoyn_message being checked to see if it was encrypted</param>
		/// <returns>Returns true if the message was encrypted.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern Int32 alljoyn_message_isencrypted(IntPtr msg);
		// extern AJ_API QCC_BOOL AJ_CALL alljoyn_message_isencrypted(alljoyn_message msg);

		/// <summary>
		/// Get the name of the authentication mechanism that was used to generate the encryption key if
		/// the message is encrypted.
		/// </summary>
		/// <param name="msg">alljoyn_message the authentication mechanism is being obtained from</param>
		/// <returns>the name of an authentication mechanism or an empty string.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_getauthmechanism(IntPtr msg);
		// extern AJ_API const char* AJ_CALL alljoyn_message_getauthmechanism(alljoyn_message msg);

		/// <summary>
		/// Return the type of the message
		/// </summary>
		/// <param name="msg">alljoyn_message being read for its alljoyn_messagetype</param>
		/// <returns>message type</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern alljoyn_messagetype alljoyn_message_gettype(IntPtr msg);
		// extern AJ_API alljoyn_messagetype AJ_CALL alljoyn_message_gettype(alljoyn_message msg);

		/// <summary>
		/// Return the arguments for this message.
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the arguments.</param>
		/// <param name="numArgs">The number of arguments</param><!-- out -->
		/// <param name="args">Returns the arguments</param><!-- out -->
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_message_getargs(IntPtr msg, UIntPtr numArgs, IntPtr args);
		// extern AJ_API void AJ_CALL alljoyn_message_getargs(alljoyn_message msg, size_t* numArgs, alljoyn_msgarg* args);

		/// <summary>
		/// Return a specific argument.
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract an argument.</param>
		/// <param name="argN">The index of the argument to get.</param>
		/// <returns>- The argument
		/// - NULL if unmarshal failed or there is not such argument.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_getarg(IntPtr msg, UIntPtr argN);
		// extern AJ_API const alljoyn_msgarg AJ_CALL alljoyn_message_getarg(alljoyn_message msg, size_t argN);

		/// <summary>
		/// Unpack and return the arguments for this message. This function uses the
		/// functionality from alljoyn_msgarg_get() see MsgArg.h for documentation.
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the arguments.</param>
		/// <param name="signature">The signature to match against the message arguments.</param>
		/// <param name="...">Pointers to return references to the unpacked values.</param><!-- out -->
		/// <returns>ER_OK if successful.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern QStatus alljoyn_message_parseargs(IntPtr msg, [MarshalAs(UnmanagedType.LPStr)]string signature/*TODO: '...' type*/);
		// extern AJ_API QStatus AJ_CALL alljoyn_message_parseargs(alljoyn_message msg, const char* signature, ...);

		/// <summary>
		/// Accessor function to get serial number for the message. Usually only important for
		/// #ALLJOYN_MESSAGE_METHOD_CALL for matching up the reply to the call.
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the serial.</param>
		/// <returns>the serial number of the %Message</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern UInt32 alljoyn_message_getcallserial(IntPtr msg);
		// extern AJ_API uint32_t AJ_CALL alljoyn_message_getcallserial(alljoyn_message msg);

		/// <summary>
		/// Accessor function to get the signature for this message
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the signature.</param>
		/// <returns>- The AllJoyn SIGNATURE string stored in the AllJoyn header field
		/// - An empty string if unable to find the AllJoyn signature</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_getsignature(IntPtr msg);
		// extern AJ_API const char* AJ_CALL alljoyn_message_getsignature(alljoyn_message msg);

		/// <summary>
		/// Accessor function to get the object path for this message
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the object path.</param>
		/// <returns>- The AllJoyn object path string stored in the AllJoyn header field
		/// - An empty string if unable to find the AllJoyn object path</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_getobjectpath(IntPtr msg);
		// extern AJ_API const char* AJ_CALL alljoyn_message_getobjectpath(alljoyn_message msg);

		/// <summary>
		/// Accessor function to get the interface for this message
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the interface name.</param>
		/// <returns>- The AllJoyn interface string stored in the AllJoyn header field
		/// - An empty string if unable to find the interface</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_getinterface(IntPtr msg);
		// extern AJ_API const char* AJ_CALL alljoyn_message_getinterface(alljoyn_message msg);

		/// <summary>
		/// Accessor function to get the member (method/signal) name for this message
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the member name.</param>
		/// <returns>- The AllJoyn member (method/signal) name string stored in the AllJoyn header field
		/// - An empty string if unable to find the member name</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_getmembername(IntPtr msg);
		// extern AJ_API const char* AJ_CALL alljoyn_message_getmembername(alljoyn_message msg);

		/// <summary>
		/// Accessor function to get the reply serial number for the message. Only meaningful for #ALLJOYN_MESSAGE_METHOD_RET
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the reply serial.</param>
		/// <returns>- The serial number for the message stored in the AllJoyn header field
		/// - Zero if unable to find the serial number. Note that 0 is an invalid serial number.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern UInt32 alljoyn_message_getreplyserial(IntPtr msg);
		// extern AJ_API uint32_t AJ_CALL alljoyn_message_getreplyserial(alljoyn_message msg);

		/// <summary>
		/// Accessor function to get the sender for this message.
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the sender information.</param>
		/// <returns>- The senders well-known name string stored in the AllJoyn header field.
		/// - An empty string if the message did not specify a sender.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_getsender(IntPtr msg);
		// extern AJ_API const char* AJ_CALL alljoyn_message_getsender(alljoyn_message msg);

		/// <summary>
		/// Get the unique name of the endpoint that the message was received on.
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the endpoint information.</param>
		/// <returns>- The unique name of the endpoint that the message was received on.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_getreceiveendpointname(IntPtr msg);
		// extern AJ_API const char* AJ_CALL alljoyn_message_getreceiveendpointname(alljoyn_message msg);

		/// <summary>
		/// Accessor function to get the destination for this message
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the destination information.</param>
		/// <returns>- The message destination string stored in the AllJoyn header field.
		/// - An empty string if unable to find the message destination.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_getdestination(IntPtr msg);
		// extern AJ_API const char* AJ_CALL alljoyn_message_getdestination(alljoyn_message msg);

		/// <summary>
		/// Accessor function to get the session id for the message.
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the session id information.</param>
		/// <returns>- Session id for the message
		/// - 0 'zero' if sender did not specify a session</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_getsessionid(IntPtr msg);
		// extern AJ_API alljoyn_sessionid AJ_CALL alljoyn_message_getsessionid(alljoyn_message msg);

		/// <summary>
		/// If the message is an error message returns the error name and optionally the error message string
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the error name information.</param>
		/// <param name="errorMessage-">Return the error message string stored
		/// - leave errorMessage unchanged if error message string not found</param><!-- out -->
		/// <param name="errorMessage_size">size of the errorMessage string (including the terminating nul byte)if errorMessage == NULL this will be changed to the
		/// size of the string so a buffer can be allocated to
		/// hold the string.</param><!-- in, out -->
		/// <returns>- If error detected return error name stored in the AllJoyn header field
		/// - NULL if error not detected</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_message_geterrorname(IntPtr msg, [MarshalAs(UnmanagedType.LPStr)] out string errorMessage, [In, Out]UIntPtr errorMessage_size);
		// extern AJ_API const char* AJ_CALL alljoyn_message_geterrorname(alljoyn_message msg, char* errorMessage, size_t* errorMessage_size);

		/// <summary>
		/// Returns an XML string representation of the message
		/// </summary>
		/// <param name="msg">The alljoyn_message which to return an XML representation of.</param>
		/// <param name="str">The character string that will hold the XML stringrepresentation of the alljoyn_message</param><!-- out -->
		/// <param name="buf">The size of the char* array that will hold the string</param>
		/// <returns>The number of characters (including the terminating nul byte) whichwould have been written to the final string if enough space
		/// available.  Thus returning a value of buf or larger means the output
		/// was truncated.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern UIntPtr alljoyn_message_tostring(IntPtr msg, sbyte str, UIntPtr buf);
		// extern AJ_API size_t AJ_CALL alljoyn_message_tostring(alljoyn_message msg, char* str, size_t buf);

		/// <summary>
		/// Returns a string that provides a brief description of the message
		/// </summary>
		/// <param name="msg">The alljoyn_message which to return an XML representation of.</param>
		/// <param name="str">The character string that will hold the description of themessage</param><!-- out -->
		/// <param name="buf">The size of the char* array that will hold the string</param>
		/// <returns>The number of characters (including the terminating nul byte) whichwould have been written to the final string if enough space
		/// available.  Thus returning a value of buf or larger means the output
		/// was truncated.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern UIntPtr alljoyn_message_description(IntPtr msg, sbyte str, UIntPtr buf);
		// extern AJ_API size_t AJ_CALL alljoyn_message_description(alljoyn_message msg, char* str, size_t buf);

		/// <summary>
		/// Returns the timestamp (in milliseconds) for this message. If the message header contained a
		/// timestamp this is the estimated timestamp for when the message was sent by the remote device,
		/// otherwise it is the timestamp for when the message was unmarshaled. Note that the timestamp
		/// is always relative to local time.
		/// </summary>
		/// <param name="msg">The alljoyn_message from which to extract the timestamp information.</param>
		/// <returns>The timestamp for this message.</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern UInt32 alljoyn_message_gettimestamp(IntPtr msg);
		// extern AJ_API uint32_t AJ_CALL alljoyn_message_gettimestamp(alljoyn_message msg);

		/// <summary>
		/// Equality operation.
		/// </summary>
		/// <param name="one">alljoyn_interfacedescription_member to compare to other</param>
		/// <param name="other">alljoyn_interfacedescription_member to compare to one</param>
		/// <returns>QCC_TRUE if one == other</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern Int32 alljoyn_message_eql(IntPtr one, IntPtr other);
		// extern AJ_API QCC_BOOL AJ_CALL alljoyn_message_eql(const alljoyn_message one, const alljoyn_message other);

		/// <summary>
		/// Set the endianness for outgoing messages. This is mainly for testing purposes.
		/// </summary>
		/// <param name="endian">Either ALLJOYN_LITTLE_ENDIAN or ALLJOYN_BIG_ENDIAN. Any other valuesets the endianness to the native endianness for this platform.</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_message_setendianess(sbyte endian);
		// extern AJ_API void AJ_CALL alljoyn_message_setendianess(const char endian);


    }
}