// Generated from Observer.h

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace AllJoynDotNet
{
		/// <summary>
		/// Callback to be invoked when a new object has been discovered.
		/// </summary>
		/// <param name="context">the context pointer that was passed into thealljoyn_observerlistener_create function</param>
		/// <param name="proxyref">a reference to a proxy bus object supporting all interfacesannounced in the About signal.</param>
		/// 
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void alljoyn_observer_object_discovered_ptr(IntPtr context, IntPtr proxyref);
		// typedef void (AJ_CALL * alljoyn_observer_object_discovered_ptr)(const void* context,
		// alljoyn_proxybusobject_ref proxyref);
		// 

		/// <summary>
		/// Callback to be invoked when a previously discovered object has been lost.
		/// </summary>
		/// <param name="context">the context pointer that was passed into thealljoyn_observerlistener_create function</param>
		/// <param name="proxyref">a reference to the proxy bus object representing the objectthat has been lost.</param>
		/// 
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void alljoyn_observer_object_lost_ptr(IntPtr context, IntPtr proxyref);
		// typedef void (AJ_CALL * alljoyn_observer_object_lost_ptr)(const void* context,
		// alljoyn_proxybusobject_ref proxyref);
		// 

		/// <summary>
		/// The callbacks used for creation of an alljoyn_observerlistener.
		/// </summary>
		/// 
		[StructLayout(LayoutKind.Sequential)]
		internal partial class alljoyn_observerlistener_callback
		{
			public alljoyn_observer_object_discovered_ptr object_discovered;
			public alljoyn_observer_object_lost_ptr object_lost;
			//
			///**
			//* A new object has been discovered.
			//*/
			//alljoyn_observer_object_discovered_ptr object_discovered;
			///**
			//* A previously discovered object has been lost.
			//*/
			//alljoyn_observer_object_lost_ptr object_lost;
			//
		}
		// typedef struct {
		// /**
		// * A new object has been discovered.
		// */
		// alljoyn_observer_object_discovered_ptr object_discovered;
		// /**
		// * A previously discovered object has been lost.
		// */
		// alljoyn_observer_object_lost_ptr object_lost;
		// } alljoyn_observerlistener_callback;
		// 

//
    public partial class Observer : AllJoynWrapper
    {
        internal Observer(IntPtr handle) : base(handle) { }
		/// <summary>
		/// Allocate a new alljoyn_observerlistener.
		/// </summary>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_observerlistener_create(alljoyn_observerlistener_callback callback, IntPtr context);
		// extern AJ_API alljoyn_observerlistener AJ_CALL alljoyn_observerlistener_create(const alljoyn_observerlistener_callback* callback,const void* context);

		/// <summary>
		/// Free an alljoyn_observerlistener.
		/// </summary>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_observerlistener_destroy(IntPtr listener);
		// extern AJ_API void AJ_CALL alljoyn_observerlistener_destroy(alljoyn_observerlistener listener);

		/// <summary>
		/// Create a new alljoyn_observer.
		/// </summary>
		/// <param name="bus">Bus attachment to which the Observer is attached.</param>
		/// <param name="mandatoryInterfaces">Set of interface names that a bus objectMUST implement to be discoverable by this Observer.</param>
		/// <param name="numMandatoryInterfaces">number of elements in the mandatoryInterfaces array.</param>
		/// <returns>the newly created Observer.Some things to take into account:
		/// - the Observer will only discover objects that are announced through About.
		/// - the interface names in mandatoryInterfaces must correspond with
		/// InterfaceDescriptions that have been registered with the bus attachment
		/// before creation of the Observer.
		/// - mandatoryInterfaces must not be empty or NULL</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_observer_create(IntPtr bus, [MarshalAs(UnmanagedType.LPStr)]string[] mandatoryInterfaces, UIntPtr numMandatoryInterfaces);
		// extern AJ_API alljoyn_observer AJ_CALL alljoyn_observer_create(alljoyn_busattachment bus,const char* mandatoryInterfaces[],size_t numMandatoryInterfaces);

		/// <summary>
		/// Destroy an alljoyn_observer.
		/// </summary>
		/// <param name="observer">the alljoyn_observer to destroy.</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_observer_destroy(IntPtr observer);
		// extern AJ_API void AJ_CALL alljoyn_observer_destroy(alljoyn_observer observer);

		/// <summary>
		/// Register a listener.
		/// </summary>
		/// <param name="observer">the observer this call is made for</param>
		/// <param name="listener">the listener to register</param>
		/// <param name="triggerOnExisting">trigger object_discovered callbacks foralready-discovered objects</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_observer_registerlistener(IntPtr observer, IntPtr listener, Int32 triggerOnExisting);
		// extern AJ_API void AJ_CALL alljoyn_observer_registerlistener(alljoyn_observer observer,alljoyn_observerlistener listener,QCC_BOOL triggerOnExisting);

		/// <summary>
		/// Unregister a listener.
		/// </summary>
		/// <param name="observer">the observer this call is made for</param>
		/// <param name="listener">the listener to unregister</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_observer_unregisterlistener(IntPtr observer, IntPtr listener);
		// extern AJ_API void AJ_CALL alljoyn_observer_unregisterlistener(alljoyn_observer observer,alljoyn_observerlistener listener);

		/// <summary>
		/// Unregister all listeners.
		/// </summary>
		/// <remarks>
		/// <para>There is no real need to unregister all listeners before the Observer
		/// is destroyed, but it is considered good style to do so.
		/// </para>
		/// </remarks>
		/// <param name="observer">the observer this call is made for</param>
		/// 
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern void alljoyn_observer_unregisteralllisteners(IntPtr observer);
		// extern AJ_API void AJ_CALL alljoyn_observer_unregisteralllisteners(alljoyn_observer observer);

		/// <summary>
		/// Get a reference to a proxy object.
		/// </summary>
		/// <remarks>
		/// <para>If the requested object is not tracked by this observer, NULL is returned instead.
		/// The reference that is returned belongs to you. You are responsible for decrementing
		/// its refcount to avoid memory leaks.
		/// </para>
		/// </remarks>
		/// <param name="observer">The observer this call is made for</param>
		/// <param name="uniqueBusName">The unique bus name of the peer hosting the objectyou want to retrieve.</param>
		/// <param name="objectPath">The path of the object you want to retrieve.</param>
		/// <returns>an alljoyn_proxybusobject_ref or NULL</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_observer_get(IntPtr observer, [MarshalAs(UnmanagedType.LPStr)]string uniqueBusName, [MarshalAs(UnmanagedType.LPStr)]string objectPath);
		// extern AJ_API alljoyn_proxybusobject_ref AJ_CALL alljoyn_observer_get(alljoyn_observer observer,const char* uniqueBusName,const char* objectPath);

		/// <summary>
		/// Get a reference to the first proxy object.
		/// </summary>
		/// <remarks>
		/// <para>The getfirst/getnext pair of functions is useful for iterating over all discovered
		/// objects. The iteration is over when either call returns NULL.
		/// </para>
		/// <para>The reference remains valid until you pass it into alljoyn_observer_getnext. If you
		/// want to keep it around for longer than that, you have to manually increase the reference
		/// count. If you never call alljoyn_observer_getnext with this reference, then it's up to
		/// you to decrement the reference count when you're done with it.
		/// </para>
		/// </remarks>
		/// <param name="observer">the observer this call is made for</param>
		/// <returns>an alljoyn_proxybusobject_ref or NULL</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_observer_getfirst(IntPtr observer);
		// extern AJ_API alljoyn_proxybusobject_ref AJ_CALL alljoyn_observer_getfirst(alljoyn_observer observer);

		/// <summary>
		/// Get a reference to the next proxy object.
		/// </summary>
		/// <remarks>
		/// <para>The getfirst/getnext pair of functions is useful for iterating over all discovered
		/// objects. The iteration is over when either call returns NULL.
		/// </para>
		/// <para>The reference remains valid until you pass it into alljoyn_observer_getnext. If you
		/// want to keep it around for longer than that, you have to manually increase the reference
		/// count. If you never call alljoyn_observer_getnext with this reference, then it's up to
		/// you to decrement the reference count when you're done with it.
		/// </para>
		/// </remarks>
		/// <param name="observer">the observer this call is made for</param>
		/// <param name="proxyref">This method will return the proxy object immediately following this one</param>
		/// <returns>an alljoyn_proxybusobject or NULL</returns>
		[DllImport(Constants.DLL_IMPORT_TARGET)]
		internal static extern IntPtr alljoyn_observer_getnext(IntPtr observer, IntPtr proxyref);
		// extern AJ_API alljoyn_proxybusobject_ref AJ_CALL alljoyn_observer_getnext(alljoyn_observer observer,alljoyn_proxybusobject_ref proxyref);


    }
}